
#' @title Une los cambios del seccionado del INE
#'
#' @description Une los cambios del seccionado del INE (tomando como referencia
#'   la cartografía INE 2011), adaptando a su vez las poblaciones por sexo año y
#'   sección censal. Si el archivo de cambios incorpora información catastral
#'   (número de viviendas afectada por cada cambio de sección), se puede fijar
#'   un umbral de cambio (\%) para rechazar aquellos cambios que involucren a
#'   muy pocas viviendas.
#'
#' @details La función trabaja con la siguiente dinámica:
#'
#'   \itemize{ \item Filtrado del archivo de cambios según el rango de años
#'   escogido. \item Para cada cambio, si ambas secciones existen en la
#'   cartografía proporcionada se calculan las distancias (en metros) entre
#'   ellas. \item Si se ha decidido utilizar el filtro de catastro, se calcula
#'   el porcentaje de viviendas implicadas en cada cambio (opción no disponible
#'   para Euskadi y Navarra), y se procede al filtrado del archivo de cambios
#'   según el umbral escogido en la llamada a la función, asegurando siempre la
#'   presencia de aquellos cambios que implequen a secciones que no existan en
#'   la cartografía proporcionada, y restringiendo el filtrado a secciones que
#'   disten menos de 100 metros entre sí. \item  En caso de no utilizar el
#'   filtro de catastro, se filtra el archivo de cambios asegurando siempre la
#'   presencia de aquellos cambios que implequen a secciones que no existan en
#'   la cartografía proporcionada, y restringiendo el filtrado a secciones que
#'   disten menos de 100 metros entre sí. \item Una vez que se dispone del
#'   archivo de cambios definitivo, se crean las agrupaciones de secciones, y se
#'   realiza la unión de las mismas en la cartografía. \item Si se proporciona
#'   un archivo de poblaciones, se agrega la población empleando las mismas
#'   agrupaciones de secciones del punto previo.}
#'
#'   No obstante, y dado que la función asume que el callejero, el archivo de
#'   poblaciones y la cartografía están libres de errores. Como puede
#'   imaginarse, esto no es así, de modo que la función puede comportarse de
#'   forma inestable en dos supuestos:
#'
#'   \enumerate{ \item Cuando se quiera unir cambios no solo en la cartografía
#'   sino también en los datos de población, puede aparecer un comportamiento
#'   inestable de la funció, debido a divergencias existentes en la información
#'   contenida en los datos de población y en los trameros (que es desde donde
#'   se crea el listado de cambios de sección), a pesar de que en ambos casos la
#'   fuente de información es el propio INE.
#'
#'   Lo anterior se traduce en que, para determinadas consultas, el número de
#'   secciones contenidas en los datos de cartografía y poblaciones no será el
#'   mismo. Cuando esto pase (si pasa) la función devolverá un aviso, indicando
#'   qué secciones se ven afectadas y en qué años, de forma que el usuario pueda
#'   tratar de solucionarlo por su cuenta, aunque no hay una solución perfecta.
#'
#'   Las dos soluciones más efectivas (aunque son soluciones \emph{ad hoc} y
#'   recae en el usuario encontrar la más apropiada para su consulta concreta)
#'   que se han encontrado son:
#'
#'   \itemize{ \item modificar los criterios temporales de la consulta,
#'   ampliando o reduciendo el marco temporal (p. ej., pasar de un período
#'   2001:2015 a 1996:2015 o 2002:2014); \item consultar las secciones
#'   problemáticas (accesibles mediante la consulta \code{attr(objeto_devuelto,
#'   "sc_not_in_cartografia")}) en los datos de población y, en base al archivo
#'   de cambios de sección, decidir con qué sección se debería realizar la
#'   unión.}
#'
#'   \item Por otra parte, es posible encontrar vías que aparecen literalmente
#'   "de la nada", especialmente en barrios de nueva creación o gran expansión.
#'   El proceso de detección de cambios de sección (función
#'   \code{\link{detecta_cambios}}) compara las secciones a las que se asigna
#'   cada tramo del callejero de 2011, con las secciones a las que se asignan
#'   esos mismos tramos (u otros pero contengan portales asociados a los tramos
#'   previos) en los callejeros del resto de años.
#'
#'   No obstante, esto plantea un problema en la detección de cambios al
#'   considerar la aparición de vías completamente nuevas, puesto que la
#'   comparación 2011-otros años no es posible. En esos casos, y siempre que no
#'   haya uniones adicionales que resuelvan el problema por sí solo, el archivo
#'   de poblaciones tras la unión contendrá valores iguales a uno en todas las
#'   categorías de edad para los años anteriores a la creación de la vía.
#'   Nuevamente, cuando esto pase (si pasa) la función devolverá un aviso,
#'   indicando qué secciones se ven afectadas y en qué años, de forma que el
#'   usuario pueda tratar de solucionarlo por su cuenta.
#'
#'   La solución a este problema es similar al lo anteriormente expuesto: por un
#'   lado se puede variar el rango de años, y por otro tratar de solucionarlo
#'   manualmente consultando el archivo de cambios de sección y el de
#'   poblaciones, buscando las secciones que devuelva la consulta
#'   \code{attr(resultado, "pob_igual_uno")}.}
#'
#'   En el apartado de ejemplos se desarrollarán los abordajes a estos
#'   problemas, con un tratamiento más extenso en la viñeta de unión de
#'   seccionado (aún por elaborar).
#'
#' @param cambios Objeto de clase \code{cambios_ine}.
#' @param cartografia Objeto de clase \code{\link[sp]{SpatialPolygons}}, y con
#'   datos de clase \code{cartografia_ine}.
#' @param years Vector numérico de longitud >= 1 con los años para los que se
#'   desee consultar las variaciones de seccionado. El año 2011 debe figurar
#'   dentro del vector, cuyo rango debe ser continuo (sin saltos de más de un
#'   año).
#' @param poblacion Objeto de clase \code{poblaciones_ine}. Argumento opcional a
#'   proporcionar en caso de querer agregar las poblaciones.
#' @param corte_edad Numérico: punto de corte para los grupos de edad (85 o
#'   100). Argumento opcional en caso de proporcionar datos de poblaciones.
#' @param catastro Lógico: ¿Debe aplicarse el filtro de información catastral?
#'   Por defecto \code{catastro = FALSE}.
#' @param umbral_vivienda Numérico: porcentaje de viviendas afectadas en el
#'   cambio de sección. Solo se utiliza si \code{catastro = TRUE}. Por defecto
#'   se fija al 5 \%.
#' @param distancia Numérico: Máxima distancia (en metros) de separación entre
#'   secciones. Por defecto se fija en 100 metros. En algunos casos
#'   (principalmente en ciudades donde no haya problemas con pedanías que
#'   compartan nombres de vía con el núcleo urbano principal) puede ser
#'   conveniente aumentar este parámetro.
#' @param modo Carácter: Modalidad de la unión (\code{auto} o \code{manual}), por
#'   defecto \code{auto}. Si se escoge el modo \code{auto} la función detectará
#'   los cambios que conllevan una unión de secciones según los parámetros que
#'   el usuario haya elegido; si se escoge el modo \code{manual}, además de
#'   realizar todo el proceso que involucra el otro modo, se permite al usuario
#'   incluir uniones que el modo \code{auto} puede haber pasado por alto,
#'   realizando uniones de seccionado 1-1 mediante los argumentos \code{sc1} y
#'   \code{sc2}.
#' @param sc1 Vector de caracteres: Primer bloque de secciones a unir
#'   manualmente, vacío por defecto. Si se proporciona debe tener la misma
#'   longitud que \code{sc2}.
#' @param sc2 Vector de caracteres: Segundo bloque de secciones a unir
#'   manualmente, vacío por defecto. Si se proporciona debe tener la misma
#'   longitud que \code{sc1}.
#'
#' @usage une_secciones(cambios, cartografia, years = 1996:2016, poblacion =
#'   NULL, corte_edad = 85, catastro = FALSE, umbral_vivienda = 5, distancia =
#'   100, modo = c("auto", "manual"), sc1 = NULL, sc2 = NULL)
#'
#' @return El resultado devuelto varía en función de si se proporcionan datos de
#'   poblaciones o no. Si no se proporcionan se devuelve un objeto de clase
#'   \code{cartografia_ine} y \code{\link[sp]{SpatialPolygons}} con la
#'   cartografía, donde cada fila es una sección censal y que cuenta con 9
#'   columnas: \describe{\item{seccion}{Cadena de 10 caracteres con el código de
#'   sección censal (incluye provincia, municipio y distrito).}
#'   \item{CUMUN}{Cadena de 5 caracteres con el código del municipio (incluye
#'   provincia).} \item{CCA}{Cadena de 2 caracteres con el código de comunidad
#'   autónoma.} \item{NPRO}{Nombre de la provincia.} \item{NCA}{Nombre de la
#'   comunidad autónoma.} \item{NMUN}{Nombre del municipio.}
#'   \item{geometry}{Columna de tipo lista con la geometría asociada a cada
#'   sección censal.} \item{cluster_id}{Código de identificación del cluster de
#'   uniones.} \item{sc_unida}{Código de las secciones unidas.}}
#'
#'   En caso de proporcionan poblaciones, se devuelve una lista de longitud
#'   igual a dos, donde el primer elemento es la cartografía descrita
#'   anteriormente y el segundo elemento de la lista es un objeto de clase
#'   \code{poblaciones_ine} donde las filas representan las distintas secciones
#'   censales. Las tres primeras columnas son: \describe{\item{seccion}{Código
#'   de la sección censal.} \item{sexo}{Sexo de la población (0 = masculino; 1 =
#'   femenino).} \item{year}{Año de referencia.}} El resto de columnas
#'   representan los distintos grupos de edad, tras realizar el corte en los
#'   grupos de edad (85 0 100).
#'
#' @examples
#'
#' \dontrun{
#'   # En este ejemplo se trabaja con la ciudad de Sevilla (código ine: 41091)
#'   # en los años 2004-2015, sin usar códigos postales.
#'
#'   library(medear)
#'   data("poblacion")
#'   data("cambios_seccion")
#'   data("cartografia")
#'   cambios_se     <- cambios_seccion[substr(cambios_seccion$sc_ref, 1, 5) == "41091" &
#'                                     cambios_seccion$codigo_postal == FALSE, ]
#'   cartografia_se <- cartografia[cartografia$CUMUN == "41091", ]
#'   poblacion_se   <- poblacion[substr(poblacion$seccion, 1, 5) == "41091", ]
#'
#'   ##########################################################################
#'   ## Ejemplo sin utilizar el filtro de catastro                           ##
#'   ##########################################################################
#'
#'   union_sin_cat <- une_secciones(
#'     cambios         = cambios_se,
#'     cartografia     = cartografia_se,
#'     years           = 2004:2015,
#'     poblacion       = poblacion_se,
#'     catastro        = FALSE,
#'     distancia       = 100
#'   )
#'
#'   nrow(union_sin_cat$cartografia) # 402 secciones
#'   length(unique(union_sin_cat$poblacion$seccion)) # 408 secciones
#'   round(nrow(union_sin_cat$cartografia) / nrow(cartografia_se) * 100) #
#'   Conserva el 76 \% de secciones
#'
#'   # La función avisa acerca de divergencias en el seccionado entre
#'   cartografía y el archivo de poblaciones. # Las secciones afectadas son
#'   accesibles mediante la siguiente consulta:
#'   attributes(union_con_cat)$sc_not_in_cartografia # 12 SC problemáticas
#'
#'   # En este caso, se resolverá la primera incidencia (SC 4109102089).
#'   sc_problematica <- attributes(union_con_cat)$sc_not_in_cartografia[1]
#'
#'   ## POR COMPLETAR ##
#'
#'
#'   ##########################################################################
#'   ## Ejemplo utilizando el filtro de catastro                             ##
#'   ##########################################################################
#'
#'   union_con_cat <- une_secciones(
#'     cambios         = cambios_se,
#'     cartografia     = cartografia_se,
#'     years           = 2004:2015,
#'     poblacion       = poblacion_se,
#'     catastro        = TRUE,
#'     umbral_vivienda = 5,
#'     distancia       = 100
#'   )
#'
#'   nrow(union_con_cat$cartografia) # 466 secciones
#'   length(unique(union_con_cat$poblacion$seccion)) # 478 secciones
#'   round(nrow(union_con_cat$cartografia) / nrow(cartografia_se) * 100)
#'   # Conserva el 88 \% de secciones
#'
#'   ## POR COMPLETAR ##
#'
#' }
#'
#' @encoding UTF-8
#'
#' @export
#'
#' @seealso \code{\link{detecta_cambios}}, \code{\link{descarga_poblaciones}} y
#'   \code{\link{descarga_cartografia}}
#'
une_secciones <- function(cambios, cartografia, years = 1996:2016,
                          poblacion = NULL, corte_edad = 85, catastro = FALSE,
                          umbral_vivienda = 5, distancia = 100,
                          modo = c("auto", "manual"), sc1 = NULL, sc2 = NULL) {
  modo <- match.arg(modo)
  if (!"cambios_ine" %in% class(cambios))
    stop("El objeto 'cambios' debe ser de clase 'cambios_ine'.")
  if (!is.null(poblacion) && !"poblaciones_ine" %in% class(poblacion))
    stop("El objeto 'poblacion' debe ser de clase 'poblaciones_ine'.")
  if (!is.numeric(years) & length(years) < 2)
    stop("El objeto 'years' debe ser un vector numeric de longitud >= 2.")
  if (!2011 %in% years)
    stop("2011 debe estar incluido en el objeto 'years'.")
  if ("SpatialPolygonsDataFrame" != class(cartografia))
    stop("El objeto 'cartografia' debe ser de clase 'SpatialPolygonsDataFrame'.")
  if (is.na(sp::proj4string(cartografia)))
    stop("El objeto 'cartografia' no tiene asignado un CRS.")
  years <- sort(years)
  if (any(years != min(years):max(years)))
    stop("El rango de years debe ser continuo (sin saltos mayores a uno).")
  stopifnot(corte_edad %in% c(85, 100))
  stopifnot(is.numeric(umbral_vivienda))
  stopifnot(is.numeric(distancia))
  stopifnot(is.logical(catastro))
  stopifnot(any(cambios$sc_ref %in% cartografia$seccion))
  if (!is.null(poblacion)) stopifnot(any(cambios$sc_ref %in% poblacion$seccion))
  if (modo == "manual") stopifnot(!is.null(sc1))
  stopifnot(length(sc1) == length(sc2))
  if (!is.null(sc1)) stopifnot(is.character(c(sc1, sc2)))

  cartografia <- sp::spTransform(cartografia, sp::CRS("+init=epsg:4326"))
  if ("vias" %in% names(cambios)) cambios$vias <- NULL
  fuente     <- "Fuente: Sitio web del INE: www.ine.es"
  utils::data("secciones", envir = environment(), package = "medear")
  cambios        <- cambios[between(year2, years[1], years[length(years)])]

  if (!is.null(poblacion)) {
    poblacion <- poblacion[between(year, min(years), max(years))]

    if (!all(unique(poblacion$seccion) %in% unique(secciones$seccion))) {
      sc_pob_not_sc <- unique(poblacion$seccion)[!unique(poblacion$seccion) %in% unique(secciones$seccion)]
        secciones <- unique(
          rbindlist(
            list(
              secciones,
              poblacion[sexo == 0 & seccion %in% sc_pob_not_sc, seccion, by = year]
            )
          )
        )[order(seccion, year)]
    }
    if (!all(unique(poblacion$year) %in% unique(secciones$year))) {
      year_not_sc <- unique(poblacion$year)[!unique(poblacion$year) %in% unique(secciones$year)]
        secciones <- unique(
          rbindlist(
            list(
              secciones,
              poblacion[sexo == 0 & year %in% year_not_sc, seccion, by = year]
            )
          )
        )[order(seccion, year)]
    }

    tmp1 <- tmp2 <- list()
    secciones[, tmp := FALSE]
    for (i in years) {
      tmp1[[paste(i)]] <- unique(secciones[year == i, seccion])
    }
    tmp2[[paste(last(years))]] <- secciones[year == last(years)][, tmp := TRUE]
    for (i in years[years != last(years)]) {
      tmp2[[paste(i)]] <- secciones[year == i]
      tmp2[[paste(i)]][!tmp1[[paste(i)]] %in% tmp1[[paste(i + 1)]] == TRUE, tmp := TRUE]
    }
    secciones <- rbindlist(tmp2)
    secciones[, final := last(years)]
    secciones[tmp == TRUE, final := as.integer(year)]
    secciones[, tmp := NULL]
    sc_pob_conservar <- secciones[between(final, 2012, max(year) - 1), seccion]
    secciones_2011   <- secciones[
      year == 2011 & substr(seccion, 1, 5) %in% cambios[, substr(sc_ref, 1, 5)]
      ][, n_viv := cartografia@data[match(cartografia$seccion, seccion), "n_viv"]]
  }

  cambios$modo   <- "auto"

  if (nrow(cambios) > 0) {
    islas_2011    <- sapply(cartografia@polygons, function(x) length(x@Polygons))
    sc_islas_2011 <- cartografia@data[which(islas_2011 != 1), "seccion"]
    carto_metro   <- sp::spTransform(
      cartografia,
      sp::CRS("+proj=utm +zone=28 +datum=WGS84")
    )
    cambios$no_11 <- FALSE
    cambios$dista <- NA_real_
    for (i in seq_len(nrow(cambios))) {
      carto1 <- carto_metro[carto_metro$seccion == cambios$sc_ref[i], ]
      carto2 <- carto_metro[carto_metro$seccion == cambios$sc_new[i], ]
      if (all(nrow(carto1) > 0, nrow(carto2) > 0)) {
        cambios$dista[i] <- rgeos::gDistance(carto1, carto2)
      } else {
        cambios$no_11[i] <- TRUE
      }
    }
    cambios[, distan_T := (dista <= distancia | is.na(dista))]

    if (catastro) {
      for (i in seq_len(nrow(cambios))) {
        viv_r    <- secciones_2011[seccion == cambios[["sc_ref"]][i], n_viv]
        cambios[i, viv_ref := ifelse(length(viv_r) != 0, viv_r, NA_integer_)]
        cambios[i, cambio_ref := (viviendas / viv_ref * 100)]
      }
      cambios[, umbral := cambio_ref + tramo_por]
      cambios[, umbral_T := umbral >= umbral_vivienda]
      cambios[, incluido := umbral_T == T & (no_11 | distan_T)]
      cambios_copy <- copy(cambios)
      cambios <- cambios[incluido == TRUE]
    } else {
      cambios[, incluido := no_11 == TRUE | distan_T]
      cambios_copy <- copy(cambios)
      cambios      <- cambios[incluido == TRUE]
    }

    sc_pob_conservar <- cambios_copy[
      (sc_ref %in% sc_pob_conservar | sc_new %in% sc_pob_conservar) &
        year2 > 2011
    ]
    cambios <- unique(rbindlist(list(cambios, sc_pob_conservar)))

    if (modo == "manual") {
      cambios_m <- cambios_copy[seq_len(length(sc1))]
      cambios_m[, `:=`(
        sc_ref     = sc1,
        sc_new     = sc2,
        year       = NA_integer_,
        year2      = NA_integer_,
        viviendas  = NA_integer_,
        tramo_por  = NA_real_,
        modo       = "manual",
        no_11      = NA,
        dista      = NA_real_,
        distan_T   = NA,
        viv_ref    = NA_integer_,
        cambio_ref = NA_real_,
        umbral     = NA_real_,
        umbral_T   = NA,
        incluido   = TRUE
      )]
      cambios_copy <- rbindlist(list(cambios_copy, cambios_m))
      cambios      <- rbindlist(list(cambios, cambios_m))
    }

    sc_unicas <- sort(
      unique(
        secciones[
          year %in% years & seccion %in% c(cambios$sc_ref, cambios$sc_new),
          seccion
        ]
      )
    )
    cluster_sc <- data.table(sc = sc_unicas, id_cluster = sc_unicas)
    for (i in seq_len(nrow(cambios))) {
      sc_select <- which(cluster_sc[, sc] %in% cambios[i, c(sc_ref, sc_new)])
      sc_min    <- min(cluster_sc[sc_select, id_cluster])
      sc_assign <- which(cluster_sc[, id_cluster] %in%
                           cluster_sc[sc_select, id_cluster])
      cluster_sc[sc_assign, id_cluster := sc_min][]
    }
    cluster_sc <- cluster_sc[order(id_cluster)]
    indice_ini <- which(cluster_sc$sc == cluster_sc$id_cluster)
    indice_fin <- c(indice_ini[-1] - 1, nrow(cluster_sc))
    id_cluster <- character(length(indice_ini))
    sc_ini     <- character(length(indice_ini))
    for (i in seq_along(indice_ini)) {
      sc_ini[i]     <- cluster_sc[indice_ini[i], sc]
      id_cluster[i] <- paste(cluster_sc[indice_ini[i]:indice_fin[i], sc], collapse = "-")
    }

    cartografia$cluster_id <- cluster_sc$id_cluster[match(cartografia$seccion, cluster_sc$sc)]
    cartografia$cluster_id[is.na(cartografia$cluster_id)] <-
      cartografia$seccion[is.na(cartografia$cluster_id)]
    cartografia <- stats::aggregate(
      x   = cartografia,
      by  = list(cartografia$cluster_id),
      FUN = function(x) x[[1]]
    )
    cartografia$seccion    <- cartografia$cluster_id
    cartografia$cluster_id <- NA_character_
    for (i in seq_along(sc_ini)) {
      cartografia$cluster_id[cartografia$seccion == sc_ini[i]] <- id_cluster[i]
    }
    cartografia$Group.1 <- NULL

    islas_union    <- which(sapply(cartografia@polygons, function(x) length(x@Polygons)) != 1)
    sc_islas_union <- cartografia@data[islas_union, "seccion"]
    all_sc_islas   <- strsplit(cartografia@data[islas_union, "cluster_id"], "-")
    sc_comparacion <- ifelse(length(sc_islas_2011) == 0, TRUE, FALSE)
    if (!sc_comparacion & length(sc_islas_union) > 0) {
      sc_comparacion <- lapply(all_sc_islas, function(x) ifelse(is.na(x), TRUE, any(x %in% sc_islas_2011)))
    }
    if ((length(sc_islas_union) > 0 & (length(sc_islas_union) > length(sc_islas_2011))) |
        any(!sapply(sc_comparacion, any))) {
      if (all(any(sapply(all_sc_islas, length) > 0), length(sc_islas_2011) > 0)) {
        islas_alerta <- sc_islas_union[!sapply(sc_comparacion, any)]
      } else if (length(all_sc_islas) > 0) {
        islas_alerta <- sc_islas_union
      }
      cartografia$revision_manual[cartografia$seccion %in% islas_alerta] <- "Revisar manualmente"
      warning(
        "Las secciones de la cartograf\u00eda: c('", paste(islas_alerta, collapse = "-"), "'),",
        " est\u00e1n conformadas por varios pol\u00edgonos que no son colindantes.\n",
        "Por favor, rev\u00edselas manualmente (consulte la ayuda de la funci\u00f3n).",
        call. = FALSE
      )
    }
  } else if (is.null(poblacion)) {
    attributes(cartografia@data)$cambios <- cambios_copy
    message("En el per\u00edodo establecido no se ha detectado ning\u00fan cambio: ",
            "se devuelve la misma cartograf\u00eda.")
  }
  attributes(cartografia@data)$fuente  <- fuente
  res <- cartografia


  if (!is.null(poblacion)) {
    poblacion <- elige_corte(poblacion, corte_edad)
    if (nrow(cambios) > 0) {
      poblacion[, cluster := cluster_sc[match(seccion, sc), id_cluster]]
      poblacion[is.na(cluster), cluster := seccion]
      in_col <- names(poblacion)[
        !names(poblacion) %in% c("seccion", "sexo", "year", "cluster")
      ]
      poblacion <- poblacion[
        ,
        lapply(.SD, sum),
        by      = .(cluster, sexo, year),
        .SDcols = in_col
      ]
      setnames(poblacion, "cluster", "seccion")
      sc_11 <- unique(poblacion[year == 2011, seccion])
      years2 <- years[years != 2011]
      for (i in seq_along(years2)) {
        if (!all(sc_11 %in% poblacion[year == years2[i], seccion])) {
          sc_not_11 <- sc_11[which(!sc_11 %in% poblacion[year == years2[i], seccion])]
          for (j in seq_along(sc_not_11)) {
            pob1 <- poblacion[year == years2[i]][1:2]
            pob1[, `:=`(
              seccion = sc_not_11[j],
              sexo    = 0:1
            )][]
            set(pob1, j = names(pob1)[-c(1:3)], value = 1)
            poblacion <- rbindlist(list(poblacion, pob1))[order(seccion, sexo, year)]
          }
        }
      }
    } else {
      message(
        "En el per\u00edodo establecido no se ha detectado ning\u00fan cambio: ",
        "se devuelve la misma cartograf\u00eda y poblaci\u00f3n para ese per\u00edodo, ",
        "ajustando esta \u00faltima al corte de edad marcado."
      )
    }

    attributes(poblacion)$fuente <- fuente
    res                          <- list(
      cartografia = cartografia, poblacion = poblacion
    )
    attributes(res)$fuente       <- fuente
    if (exists("cluster_sc")) {
      attributes(res)$cluster    <- cluster_sc
      attributes(res)$cambios    <- cambios_copy
    }

    if (!identical(sort(cartografia$seccion), sort(unique(poblacion$seccion)))) {
      not_in_pobla <- cartografia$seccion[!cartografia$seccion %in% unique(poblacion$seccion)]
      not_in_carto <- unique(poblacion$seccion)[!unique(poblacion$seccion) %in% cartografia$seccion]
      if (length(not_in_pobla) > 0) {
        warning(
          "Tras realizar la uni\u00f3n con las opciones marcadas, las secciones c('",
          paste0(not_in_pobla, collapse = "', '"),
          "') aparecen en la cartograf\u00eda pero no en los datos de poblaci\u00f3n.\n",
          "Por favor, consulte la ayuda de la funci\u00f3n para tratar de solucionarlo.",
          call. = FALSE
        )
        attr(res, "sc_not_in_poblacion") <- not_in_pobla
      }
      if (length(not_in_carto) > 0) {
        not_in_years <- unique(poblacion[seccion %in% not_in_carto, year])
        warning(
          "Tras realizar la uni\u00f3n con las opciones marcadas, las secciones c('",
          paste0(not_in_carto, collapse = "', '"),
          "') aparecen en los datos de poblaci\u00f3n pero no en la cartograf\u00eda, ",
           " para los a\u00f1os c(", paste0(not_in_years, collapse = ", "), ").\n",
          "Por favor, consulte la ayuda de la funci\u00f3n para tratar de solucionarlo.",
          call. = FALSE
        )
        attr(res, "sc_not_in_cartografia") <- not_in_carto
        attr(attr(res, "sc_not_in_cartografia"), "years") <- not_in_years
      }
    }

    uno_vect <- rowSums(poblacion[, -c(1:3)]) == sum(ncol(poblacion[, -c(1:3)]))

    if (any(uno_vect)) {
      warning(
        "En el per\u00edodo seleccionado las secciones c('", paste0(unique(poblacion$seccion[uno_vect]), collapse = "', '"), "') no sufrieron cambios pero ",
        "aparecieron m\u00e1s tarde que el a\u00f1o de inicio elegido. Se asigna el valor 1 como ",
        "poblaci\u00f3n a dichas secciones para los a\u00f1os previos (hasta el a\u00f1o de inicio fijado).\n",
        "Por favor, consulte la ayuda de la funci\u00f3n para explorar este aspecto.",
        call. = FALSE
      )
      attr(res, "pob_igual_uno") <- unique(poblacion[uno_vect, seccion])
    }
  }

  return(res)
}
