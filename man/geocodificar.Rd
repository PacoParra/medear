% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/geocodificar.R
\encoding{UTF-8}
\name{geocodificar}
\alias{geocodificar}
\title{Implementación del algoritmo de geocodificación de direcciones}
\usage{
geocodificar(direcciones, codigos = NULL, cartografia = NULL,
nivel_filtro = c("municipio", "provincia", "ninguno"),
encoding = c("utf8", "latin1", "ascii"))
}
\arguments{
\item{direcciones}{Vector de caracteres con las direcciones a geocodificar.
Las direcciones deben proporcionarse con el formato "TIPO_DE_VÍA
NOMBRE_DE_VÍA NÚMERO_DE_VÍA, MUNICIPIO, PROVINCIA, CÓDIGO_POSTAL", donde el
número de la vía y el código postal son campos opcionales.}

\item{codigos}{Vector de caracteres de longitud igual al vector de
direcciones. Contiene los códigos INE (5 caracteres por código) de los
municipios a los que hacen referencia las direcciones. Si el valor es nulo
(opción por defecto), la función trata de averiguar el código desde la
propia dirección.}

\item{cartografia}{Objeto de clase \code{cartografia_ine} con la cartografía
que contenga las geometrías de municipios o provincias a los que hacen
referencias las direcciones.}

\item{nivel_filtro}{Vector de caracteres de longitud 1 indicando el nivel de
filtrado cartográfico a efectuar (eliminación de coordenadas devueltas pero
que no correspondan a su polígono correspondiente). Las tres opciones son
municipio (las coordenadas están dentro del polígono del municipio al que
hace referencia el código de la dirección), provincia (las coordenadas
están dentro del polígono de la provincia al que hace referencia el código
de la dirección) y ninguno.}

\item{encoding}{Vector de caracteres de longitud 1 indicando el tipo de
codificación de caracteres empleada. Las posibles opciones son UTF8,
Latin-1 y ASCII (UTF8 por defecto).}
}
\value{
Un \code{data.frame} con tantas filas como direcciones se
  proporcionaron y con que cuenta con 10 columnas:
  \item{id}{Identificación de la dirección (se otorga secuencialmente).}
  \item{direcciones}{Direcciones originales proporcionadas.}
  \item{geocodificados}{Resultado de la geocodificación: cc_prev o cc_new si
    alguna de las dos versiones logra geocodificar o NA si ninguna lo logra.}
  \item{lat}{Latitud devuelta.}
  \item{lng}{Longitud devuelta.}
  \item{dir_cc_old}{Direcciones devueltas por la versión previa de
    CartoCiudad.}
  \item{parimp_o}{Numeración par o impar de la dirección original.}
  \item{parimp_c}{Numeración par o impar de la dirección devuelta por la
    versión previa de CartoCiudad.}
  \item{coinciden}{Coincidencia entre las numeraciones par o impar.}
  \item{dir_cc_new}{Dirección devuelta por la nueva versión de CartoCiudad.}
}
\description{
Esta función implementa el algoritmo de geocodificación de
  MEDEA3, en el cual se realiza una primera pasada en la versión previa de
  CartoCiudad. Sobre los no geocodificados (considerando como no
  geocodificados a los que obtienen un estado diferente a 1 o 2, los que
  devuelven el portal más próximo pero sin respetar la numeración par o impar
  y los que no cumplan con el nivel de filtrado cartográfico indicado) se
  realiza una segunda pasada en la nueva versión de CartoCiudad.
}
\examples{

\dontrun{
  library(medear)
  direcciones <- c(
    "Calle Aben Al Abbar 6, Valencia, Valencia",
    "Avenida Constitución 900, Valencia, Valencia",
    "Avenida Constitución 901, Valencia, Valencia",
    "Plaza Doctor Balmis 2, Alicante, Alicante",
    "A7 150",
    "A7 3000",
    "Calle Inventadísima 1, Valencia, Valencia"
  )
  codigos <- c(rep("46250", 3), "03014", "12082", "43148", "46250")
  cartografia <- descarga_cartografia()
  geocodificar(direcciones = direcciones, codigos = codigos,
               cartografia = cartografia, nivel_filtro = "municipio",
               encoding = "utf8")
}

}
